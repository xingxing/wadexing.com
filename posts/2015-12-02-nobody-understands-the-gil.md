----
title: 无人知晓的GIL
----

### 原文:
[http://www.jstorimer.com/blogs/workingwithcode/8085491-nobody-understands-the-gil](http://www.jstorimer.com/blogs/workingwithcode/8085491-nobody-understands-the-gil)

## Part I

我的大半生都是在Ruby社区中度过的，然而MRI中臭名昭著的GIL对我而言却一直是个叵测的家伙。这是一个关于线程安全的故事，最终我们会真相大白，

最初听人提及GIL时，我不知道它是如何工作的，它做了什么事，甚至也不知道它为什么会存在。我只知道这是个蠢主意，因为它限制了并行，换句话说就是"曾经辉煌"，因为它让我的代码线程安全。后来，我总算学会了如何去爱多线程，也意识到了现实远比我设想的复杂。

我要知其然，更知其知其所以然，GIL到底是怎么工作的？但是，GIL没有规程(specification)[1]可循，亦没有文档可看。本质上说它就是一个未知行为；一个MRI的实现细节。Ruby核心组没有对它将如何工作予以承诺或担保。

也许我有点儿超前了。

如果你对GIL一无所知，花30秒钟读读下面这个简介吧：

> MRI里有个东西叫全局解释器锁(global interpreter lock)。这个锁环绕着Ruby代码的执行。即是说在一个多线程的上下文中，在任何时候只有一个线程可以执行Ruby代码。

> 因此，假如一台8核机器上跑着8个线程，在特定的时间点上也只有一个线程和一个核心在忙碌。GIL一直保护着Ruby内核，以免竞争条件造成数据混乱。把警告和优化放一边，这就是它的主旨了。


### 问题

回到2008， Ilya Grigorik 的 [《Ruby里的并行神话》](http://www.igvita.com/2008/11/13/concurrency-is-a-myth-in-ruby/)给了我对GIL的高层次理解。即使我学确实学到了更多的Ruby多线程技术，但是这个高层次认识只是对我的单方灌输。真见鬼，我最近还写了一本关于[Ruby里多线的书](http://www.jstorimer.com/products/working-with-ruby-threads)呢,但是对于GIL我就理解了这么点儿？

问题是用些"微言大义"的认识，我没法回答有深度的技术问题。特别是，我想知道GIL是否提供了关于线程安全的任何保障。让我来示范一下。

### 数组附加是非线程安全的

几乎没什么事在Ruby里是隐式线程安全的。以附加数组为例：

```ruby
array = []

5.times.map do
  Thread.new do
    1000.times do
      array << nil
    end
  end
end.each(&:join)

puts array.size
```

这里有5个线程共享一个数组对象。每个线程将nil放入数组1000次。因此，数组里应该有5000个元素，对吧？

```shell
$ ruby pushing_nil.rb
5000

$ jruby pushing_nil.rb
4446

$ rbx pushing_nil.rb
3088
```

:(

即使这个微不足道的例子，也足以揭示Ruby里的一个操作并非隐式线程安全的。或许是？实际上发生什么了呢？

请注意MRI的结果是正确的, 5000。但是JRuby和Rubinius都错了。如果你再跑一遍，你很可能会看到MRI依然正确，但是JRuby和Rubinius给出了不同的错误结果。

这些不同的结果是GIL造成的。因为MRI有GIL，即使同时有5个线程在跑，在一个时间点上也只有一个线程是活动的。JRuby和Rubinius没有GIL，所以当你有5个线程在跑，你就真的有5个线程通过获取核心在并行地跑。


在并行的Ruby实现中，这5个线程逐句通过代码，而这是非线程安全的。它们最终互相干扰，最终腐化底层数据。

### 多线程如何腐化数据

这怎么可能？我还以为Ruby会罩着我们呢，对吧？相对于通过高层次的解释来阐述技术细节，我更倾向于向你展示这在技术上的可能性。

无论你是用MRI,JRuby或是Rubinius，Ruby语言是用其他语言实现的。 MRI是用C实现的，JRuby用Java,Rubinius是Ruby和C++的混合体。于是当你有这样一个Ruby操作时：

```ruby
array <<< nil
```

实际上在底层实现上会扩展为一大堆代码。例如，下面是Array#<<在MRI中的实现：

```C
VALUE

rb_ary_push(VALUE ary, VALUE iterm)
{
   long idx = RARRAY_LEN(ary);

   ary_ensure_room_for_push(ary, 1);
   RARRAY_ASET(ary, idx, item);
   ARY_SET_LEN(ary, idx + 1);
   return ary;
}

```

注意至少4个不同的底层操作。

1. 获取数组的当前长度
2. 检查数组里是否有空间容纳其他元素。
3. 将元素附件到数组
4. 将数组的长度属性置为原值+1。

每个操作还回调用别的函数或者宏。我提到这些是为了向你们展示多线程是如何能够破坏数据的。在但线程环境中，你可以观察并简单地跟踪这个短代码的轨迹。

话句话说，我们已经习惯了以线性的方式逐句执行代码并推断"真实世界"的状态。我们通常就是这么写代码的。

当多线程乱入，这就不可行了。这很像物理变化的规则。当有两个线程，每个线程维护这个自己的代码轨迹。由于线程共享同一个内存空间，而这些线程可以同时改变"真实世界"中的状态。

一个线程可能会打扰另一个线程，从此改变事物的状态，之后原先的线程完全不知状态已经被改变了。

这里是我的小系统的基本状态：

![](http://cdn.shopify.com/s/files/1/0110/8792/files/append_base_grande.png?653)

有两个活跃线程，同时进入这个函数(C语言中的)。将1-4步看做MRI中Array#<<的伪代码实现，之前你见过的。一旦两个线程进入这个函数，就可能出现一系列事件，假设从线程A开始：


![](http://cdn.shopify.com/s/files/1/0110/8792/files/append_arrows_grande.png?655)

这看着更复杂了，但是只要跟着箭头的方向，你就可以穿过这个流程。我还加了在每个步骤上一些标签从每个线程的角度来显示各种状态。

这只是其中一种可能性。

于是线程A沿着函数的常规路径执行，但当执行到步骤3时，发生了上下文切换！线程A被暂停在当前位置。之后线程B接管了进程并运行整个函数，附加它自己的元素并增加**length**属性。

一旦线程B完事了，线程A就恢复执行。A会在其中断的位置走起。记住，线程A是在增加**length**属性前被暂停的，自然会从往下增加**length**属性。只不过，A并不知道线程B已经改变了事物的状态。

于是线程B设置**length**为1，之后线程A又把**length**设为1，尽管它们格子的元素都已经被附加到了Array上。数据已经被玩坏了。看到图中的小闪电了吗，就这这个意思。

### 但是我想Ruby会罩着我吧？

如图中例子所示，JRuby和Rubinius中的这一系列的事件会带来错误的结果。

除此之外，在JRuby和Rubinius里，事情要更为复杂，因为线程实际可以平行跑。在该图中，一个线程被暂停，另一个在运行，而在真正并行的环境里，多个线程可以同时运行。

要是你真的运行可前面的那个例子，可能会看到它总是能得到不同的错误结果。这里的上下文切换是不确定的，无法预知。它可能发生在函数运行前期，后期，或者就根本没发生。下一小节关这个我们会谈更多。


**所以，为什么Ruby不保护我们远离这些？** 出于同样的原因，其他一些编程语言内核也不提供线程安全保护：它成本太高。对所有的Ruby实现提供线程安全的数据结构不是不可能，但这需要额外的开销，拖了单线程代码的后腿。

权衡之下，你，开发者就有责任在需要的时候提供线程安全的保证。

对我而言，这提出了两个悬而未决的问题，并且我们并未潜入GIL的技术细节中。

1. 如果下上文切换是可能的，为什么MRI还能给出正确答案呢？

2. 上下文切换到底是什么鬼？

问题1是我写这篇文正的动机。对GIL高层次的认识无法回答这个问题。高层次的认识只说清了只有一个时间点上只有一个线程可以被执行。但是Ruby之下，上下文切换是不是还能在函数的中间发生呢？

但是首先.....

### 都是调度程序的错！

上下文切换源于操作系统的线程调度程序。在所有我展示过的Ruby语言实现中，一个Ruby线程依托于一个原生的操作系统线程。操作系统必须保证没有一个线程可以独霸所有可用资源，如CPU时间，于是它实现了调度算法，使得雨露均沾。

这表现为一系列的暂停会恢复。每个线程都有机会消耗资源，之后它暂停在其轨道上，以便其他线程可以有机可乘。随着时间推移，这个线程经会被不断被恢复。

这一做法提高了操作系统的效率，但也引入和一定程度的不确定性和程序正确性的难度。例如，Array#<<操作现在需要考虑到它可以随时暂停，另一个线程可以并行地执行相同的操作，改变脚下"世界"的状态。

#### 则何如？让关键操作具有原子性

如果想确保这样的线程间中断不发生，就应该使操作具有原子性。通过原子性操作，可以保证线程在完成动作前不会被打断，这就防止了我们例子中的，在步骤3被打断，并最终在步骤4时恢复导致的数据误。

是操作具有原子性的最简方案是使用锁。下面的代码会确保结果的正确，不论是在MRI,JRuby还是Rubinius里。

```ruby
array = []
mutex = Mutex.new

5.times.map do
  Thread.new do

    mutex.synchronize do
      1000.times do
        array << nil
      end
    end

   end
end.each(&:join)

puts array.size
```

它确保正确是因为使用了一个共享的互斥或者说锁。一旦一个线程进入**mutex.synchronize**内的代码块时，所有其他线程必须在进入同一代码前等待，直到这个线程执行完毕。如果你回想前面，我说过这个操作下是多行C代码，并且线程调度上下文切换可以发生在任意两行代码间。

通过原子性操作，你可以保证如果一个上下文切换在这个代码块里发生了，其他线程将无法执行相同的代码。线程调度器会观察这一点，并再切换另一个线程。这同样也保证了没有线程可以一同进入代码块并各自改变"世界"的状态。这个例子现在就是线程安全的。

### GIL也是个锁

我刚才已经展示乐怎样可以使用锁得到原子性并提供好线程安全保证。GIL也是一个锁，所以它也能保证你代码的线程安全吗？

GIL会使 **array << nil** 变成原子性操作吗？

这篇文章已经够长的了。就让我们在下一部门深入MRI的GIL来回答这些问题吧


## Part II 实现

上文书说到，我想带你深潜到MRI里去看看GIL是怎么实现的。但是首先，我想确认一下我提出了正确的问题。Part I中的疑问，但是今天我们将在MRI内找寻答案。我们将会追寻这条见首不见尾的神龙，他们管它叫GIL。

在本文的初稿中，我真的很强调GIL底层的C代码，尽可能展示它们。但过了一段时间，一些重要的信息被细节淹没了。我重头来过了，你现在看到的这一版去掉了一些C代码，多了一些解释和图示，但是对于代码水鬼们，我至少会提到C的函数名，所以你可以自己去一探究竟。

### 书接上文...

Part I 留下了两个问题：

1. GIL会使 **array << nil** 变成原子性操作吗？
2. GIL能保证你的Ruby代码线程安全吗？

第一个问题的答案在实现中找，那就让我们开始吧。

下面的片段是我们上次见过了：

```ruby
array = []
mutex = Mutex.new

5.times.map do
  Thread.new do

    mutex.synchronize do
      1000.times do
        array << nil
      end
    end

   end
end.each(&:join)

puts array.size
```

如果你假设Array是线程安全的，预计的结果是数组会有5000个元素。因为数组不是线程安全的，在JRUby和Rubinius的实现中产生了不期的结果；比5000少。这是多线程间交互切换造成的底层数据错误。

**MRI 产生了预期结果，这是侥幸还是必然呢?** 让我们用这个Ruby代码片段来进行技术深潜。

```ruby
Thread.new do
  array << nil
end
```

### 自顶而下

为了学习这个片段中到底发生了什么，我们需要MRI内部是如何衍生线程的。我们主要看**thread*.c**文件中的那些函数。这些文件中有不少迂回之处，来同时支持Windows和Posix的线程APIs，但是这个些函数都是从这些源码文件中看来的。

第一个**Thread.now**底层操作是衍生一个新的原生线程来支持Ruby线程。成为新线程主体的C函数称为[thread_start_func_2](https://github.com/ruby/ruby/blob/trunk/thread.c#L480)。让我们从高层次一看这个函数。

![](http://cdn.shopify.com/s/files/1/0110/8792/files/thread_start_func_2_grande.png?686)

这有很多样板代码，不值得一看。










[1] 译注： 参考 《编程本源》裘宗燕 译


