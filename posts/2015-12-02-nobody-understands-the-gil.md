----
title: 无人知晓的GIL
----

### 原文:
[http://www.jstorimer.com/blogs/workingwithcode/8085491-nobody-understands-the-gil](http://www.jstorimer.com/blogs/workingwithcode/8085491-nobody-understands-the-gil)

## Part I

我的大半生都是在Ruby社区中度过的，然而MRI中臭名昭著的GIL对我而言却一直是个叵测的家伙。这是一个关于线程安全的故事，最终我们会真相大白，

最初听人提及GIL时，我不知道它是如何工作的，它做了什么事，甚至也不知道它为什么会存在。我只知道这是个蠢主意，因为它限制了并行，换句话说就是"曾经辉煌"，因为它让我的代码线程安全。后来，我总算学会了如何去爱多线程，也意识到了现实远比我设想的复杂。

我要知其然，更知其知其所以然，GIL到底是怎么工作的？但是，GIL没有规程(specification)可循，亦没有文档可看。本质上说它就是一个未知行为；一个MRI的实现细节。Ruby核心组没有对它将如何工作予以承诺或担保。

也许我有点儿超前了。

如果你对GIL一无所知，花30秒钟读读下面这个简介吧：

> MRI里有个东西叫全局解释器锁(global interpreter lock)。这个锁环绕着Ruby代码的执行。即是说在一个多线程的上下文中，在任何时候只有一个线程可以执行Ruby代码。

> 因此，假如一台8核机器上跑着8个线程，在特定的时间点上也只有一个线程和一个核心在忙碌。GIL一直保护着Ruby内核，以免竞争条件造成数据混乱。把警告和优化放一边，这就是它的主旨了。


### 问题

回到2008， Ilya Grigorik 的 [《Ruby里的并行神话》](http://www.igvita.com/2008/11/13/concurrency-is-a-myth-in-ruby/)给了我对GIL的高层次理解。即使我学确实学到了更多的Ruby多线程技术，但是这个高层次认识只是对我的单方灌输。真见鬼，我最近还写了一本关于[Ruby里多线的书](http://www.jstorimer.com/products/working-with-ruby-threads)呢,但是对于GIL我就理解了这么点儿？

问题是用些"微言大义"的认识，我没法回答有深度的技术问题。特别是，我想知道GIL是否提供了关于线程安全的任何保障。让我来示范一下。

### 数组附加是非线程安全的

几乎没什么事在Ruby里是隐式线程安全的。以附加数组为例：

```ruby
array = []

5.times.map do
  Thread.new do
    1000.times do
      array << nil
    end
  end
end.each(&:join)

puts array.size
```

这里有5个线程共享一个数组对象。每个线程将nil放入数组1000次。因此，数组里应该有5000个元素，对吧？

```shell
$ ruby pushing_nil.rb
5000

$ jruby pushing_nil.rb
4446

$ rbx pushing_nil.rb
3088
```

:(

即使这个微不足道的例子，也足以揭示Ruby里的一个操作并非隐式线程安全的。或许是？实际上发生什么了呢？

请注意MRI的结果是正确的, 5000。但是JRuby和Rubinius都错了。如果你再跑一遍，你很可能会看到MRI依然正确，但是JRuby和Rubinius给出了不同的错误结果。

这些不同的结果是GIL造成的。因为MRI有GIL，即使同时有5个线程在跑，在一个时间点上也只有一个线程是活动的。JRuby和Rubinius没有GIL，所以当你有5个线程在跑，你就真的有5个线程通过获取核心在并行地跑。


在并行的Ruby实现中，这5个线程逐句通过代码，而这是非线程安全的。它们最终互相干扰，最终腐化底层数据。

### 多线程如何腐化数据

这怎么可能？我还以为Ruby会罩着我们呢，对吧？相对于通过高层次的解释来阐述技术细节，我更倾向于向你展示这在技术上的可能性。

无论你是用MRI,JRuby或是Rubinius，Ruby语言是用其他语言实现的。 MRI是用C实现的，JRuby用Java,Rubinius是Ruby和C++的混合体。于是当你有这样一个Ruby操作时：

```ruby
array <<< nil
```

实际上在底层实现上会扩展为一大堆代码。例如，下面是Array#<<在MRI中的实现：

```C
VALUE

rb_ary_push(VALUE ary, VALUE iterm)
{
   long idx = RARRAY_LEN(ary);

   ary_ensure_room_for_push(ary, 1);
   RARRAY_ASET(ary, idx, item);
   ARY_SET_LEN(ary, idx + 1);
   return ary;
}

```

注意至少4个不同的底层操作。

1. 获取数组的当前长度
2. 检查数组里是否有空间容纳其他元素。
3. 将元素附件到数组
4. 将数组的长度属性置为原值+1。

每个操作还回调用别的函数或者宏。我提到这些是为了向你们展示多线程是如何能够破坏数据的。在但线程环境中，你可以观察并简单地跟踪这个短代码的轨迹。

话句话说，我们已经习惯了以线性的方式逐句执行代码并推断"真实世界"的状态。我们通常就是这么写代码的。

当多线程乱入，这就不可行了。这很像物理变化的规则。当有两个线程，每个线程维护这个自己的代码轨迹。由于线程共享同一个内存空间，而这些线程可以同时改变"真实世界"中的状态。

一个线程可能会打扰另一个线程，从此改变事物的状态，之后原先的线程完全不知状态已经被改变了。

这里是我的小系统的基本状态：

![](http://cdn.shopify.com/s/files/1/0110/8792/files/append_base_grande.png?653)

有两个活跃线程，同时进入这个函数(C语言中的)。将1-4步看做MRI中Array#<<的伪代码实现，之前你见过的。一旦两个线程进入这个函数，就可能出现一系列事件，假设从线程A开始：


![](http://cdn.shopify.com/s/files/1/0110/8792/files/append_arrows_grande.png?655)

这看着更复杂了，但是只要跟着箭头的方向，你就可以穿过这个流程。我还加了在每个步骤上一些标签从每个线程的角度来显示各种状态。

这只是其中一种可能性。

于是线程A沿着函数的常规路径执行，但当执行到步骤3时，发生了上下文切换！线程A被暂停在当前位置。之后线程B接管了进程并运行整个函数，附加它自己的元素并增加**length**属性。

一旦线程B完事了，线程A就恢复执行。A会在其中断的位置走起。记住，线程A是在增加**length**属性前被暂停的，自然会从往下增加**length**属性。只不过，A并不知道线程B已经改变了事物的状态。

于是线程B设置**length**为1，之后线程A又把**length**设为1，尽管它们格子的元素都已经被附加到了Array上。数据已经被玩坏了。看到图中的小闪电了吗，就这这个意思。

### 但是我想Ruby会罩着我吧？

如图中例子所示，JRuby和Rubinius中的这一系列的事件会带来错误的结果。

除此之外，在JRuby和Rubinius里，事情要更为复杂，因为线程实际可以平行跑。在该图中，一个线程被暂停，另一个在运行，而在真正并行的环境里，多个线程可以同时运行。

要是你真的运行可前面的那个例子，可能会看到它总是能得到不同的错误结果。这里的上下文切换是不确定的，无法预知。它可能发生在函数运行前期，后期，或者就根本没发生。下一小节关这个我们会谈更多。


**所以，为什么Ruby不保护我们远离这些？** 出于同样的原因，其他一些编程语言内核也不提供线程安全保护：它成本太高。对所有的Ruby实现提供线程安全的数据结构不是不可能，但这需要额外的开销，拖了单线程代码的后腿。

权衡之下，你，开发者就有责任在需要的时候提供线程安全的保证。

对我而言，这提出了两个悬而未决的问题，并且我们并未潜入GIL的技术细节中。

1. 如果下上文切换是可能的，为什么MRI还能给出正确答案呢？

2. 上下文切换到底是什么鬼？

问题1是我写这篇文正的动机。对GIL高层次的认识无法回答这个问题。高层次的认识只说清了只有一个时间点上只有一个线程可以被执行。但是Ruby之下，上下文切换是不是还能在函数的中间发生呢？

但是首先.....

### 都是调度程序的错！

上下文切换源于操作系统的线程调度程序。在所有我展示过的Ruby语言实现中，一个Ruby线程依托于一个原生的操作系统线程。操作系统必须保证没有一个线程可以独霸所有可用资源，如CPU时间，于是它实现了调度算法，使得雨露均沾。

这表现为一系列的暂停会恢复。每个线程都有机会消耗资源，之后它暂停在其轨道上，以便其他线程可以有机可乘。随着时间推移，这个线程经会被不断被恢复。

这一做法提高了操作系统的效率，但也引入和一定程度的不确定性和程序正确性的难度。例如，Array#<<操作现在需要考虑到它可以随时暂停，另一个线程可以并行地执行相同的操作，改变脚下"世界"的状态。

#### 则何如？让关键操作具有原子性

如果想确保这样的线程间中断不发生，就应该使操作具有原子性。通过原子性操作，可以保证线程在完成动作前不会被打断，这就防止了我们例子中的，在步骤3被打断，并最终在步骤4时恢复导致的数据误。

是操作具有原子性的最简方案是使用锁。下面的代码会确保结果的正确，不论是在MRI,JRuby还是Rubinius里。

```ruby
array = []
mutex = Mutex.new

5.times.map do
  Thread.new do

    mutex.synchronize do
      1000.times do
        array << nil
      end
    end

   end
end.each(&:join)

puts array.size
```

它确保正确是因为使用了一个共享的互斥或者说锁。一旦一个线程进入**mutex.synchronize**内的代码块时，所有其他线程必须在进入同一代码前等待，直到这个线程执行完毕。如果你回想前面，我说过这个操作下是多行C代码，并且线程调度上下文切换可以发生在任意两行代码间。

通过原子性操作，你可以保证如果一个上下文切换在这个代码块里发生了，其他线程将无法执行相同的代码。线程调度器会观察这一点，并再切换另一个线程。这同样也保证了没有线程可以一同进入代码块并各自改变"世界"的状态。这个例子现在就是线程安全的。

### GIL也是个锁

我刚才已经展示乐怎样可以使用锁得到原子性并提供好线程安全保证。GIL也是一个锁，所以它也能保证你代码的线程安全吗？

GIL会使 **array << nil** 变成原子性操作吗？

这篇文章已经够长的了。就让我们在下一部门深入MRI的GIL来回答这些问题吧


## Part II 实现

上文书说到，我想带你深潜到MRI里去看看GIL是怎么实现的。但是首先，我想确认一下我提出了正确的问题。Part I中的疑问，但是今天我们将在MRI内找寻答案。我们将会追寻这条见首不见尾的神龙，他们管它叫GIL。

在本文的初稿中，我真的很强调GIL底层的C代码，尽可能展示它们。但过了一段时间，一些重要的信息被细节淹没了。我重头来过了，你现在看到的这一版去掉了一些C代码，多了一些解释和图示，但是对于代码水鬼们，我至少会提到C的函数名，所以你可以自己去一探究竟。

### 书接上文...

Part I 留下了两个问题：

1. GIL会使 **array << nil** 变成原子性操作吗？
2. GIL能保证你的Ruby代码线程安全吗？

第一个问题的答案在实现中找，那就让我们开始吧。

下面的片段是我们上次见过了：

```ruby
array = []
mutex = Mutex.new

5.times.map do
  Thread.new do

    mutex.synchronize do
      1000.times do
        array << nil
      end
    end

   end
end.each(&:join)

puts array.size
```

如果你假设Array是线程安全的，预计的结果是数组会有5000个元素。因为数组不是线程安全的，在JRUby和Rubinius的实现中产生了不期的结果；比5000少。这是多线程间交互切换造成的底层数据错误。

**MRI 产生了预期结果，这是侥幸还是必然呢?** 让我们用这个Ruby代码片段来进行技术深潜。

```ruby
Thread.new do
  array << nil
end
```

### 自顶而下

为了学习这个片段中到底发生了什么，我们需要MRI内部是如何衍生线程的。我们主要看**thread*.c**文件中的那些函数。这些文件中有不少迂回之处，来同时支持Windows和Posix的线程APIs，但是这个些函数都是从这些源码文件中看来的。

第一个**Thread.now**底层操作是衍生一个新的原生线程来支持Ruby线程。成为新线程主体的C函数称为[thread_start_func_2](https://github.com/ruby/ruby/blob/trunk/thread.c#L480)。让我们从高层次一看这个函数。

![](http://cdn.shopify.com/s/files/1/0110/8792/files/thread_start_func_2_grande.png?686)

这里有很多样板代码，不值得一看。我标出了值得我们关注的部分。在接近顶部的地方，新线程获取GIL。注意，这个线程会保持空闲，直到它确实获得了GIL。在函数中部，它调用你穿给**Thread.new**的那个代码块。包装事物后，它释放乐GIL并退出原生线程。

在我们的片段中，这个新线程衍生于主线程。有鉴于此，我们可以假设主线程当前正持有GIL。新线程将必须等待，直到主线程释放GIL，它才能继续。

让我们看一下当新线程尝试获取GIL时发生了什么吧。

```c
static void
gvl_acquire_common(rb_vm_t *vm)
{
  if (vm->gvl.acquired) {
    vm->gvl.waiting++;
    if (vm->gvl.waiting == 1) {
      rb_thread_wakeup_timer_thread_low();
    }

    while (vm->gvl.acquired) {
      native_cond_wait(&vm->gvl.cond, &vm->gvl.lock);
    }
```

这段代码来自[gvl_acquire_common](https://github.com/ruby/ruby/blob/trunk/thread_pthread.c#L68)函数。此函数在我们的新线程尝试获取GIL时被调用。

首先，它会检查GIL当前是否被占有了，之后它增加GIL的**waiting**属性。同我们的片段，这个值应该现在为1。紧接着的一行检查看**wating**是否是1。它正是1，于是下一行触发唤醒了个计时器线程。

计时器线程是MRI中线程系统能一路高歌的秘密武器，并避免任意线程独霸GIL。但在我们跳得太远之前，先让我们阐述一个GIL相关事物的状态，然后再来介绍计时器线程。


我前面说了几次，MRI线程依靠的是原生的操作系统线程。这是真的，但是如图中所示，每个MRI线程并行运行在各自的原生线程中。GIL阻止这样。我们需要画出GIL来让其更为接近事实。

![](http://cdn.shopify.com/s/files/1/0110/8792/files/pre-gil_2_medium.png?692)

当一个Ruby线程希望在它自己的原生线程中执行代码时，必须先获得GIL。**GIL在Ruby线程和它们各自的原生进程之间周旋，极力消减并发！** 上张图里，Ruby线程在其原生线程里可以并行执行。而第二张更接近MRI事实真相的图里，在特定时间点上只有一个线程可以获取GIL，于是代码的执行是完全不能并行的。

![](http://cdn.shopify.com/s/files/1/0110/8792/files/with-gil_medium.png?694)


对MRI核心组而言，**GIL保卫着系统的内部状态**。使用GIL，他们不需要在数据结构周围使用任何锁或者同步机制。如果两个线程不能够同时改变内部状态，也就不会有竞争条件发生了。

对你，开发者而言，这会大大限制你从MRI Ruby代码中获得的并发能力。

![](http://www.flickr.com/photos/kellyskustompinstriping/6844608535/)

### 计时器线程

我前面提到计时器线程是用来避免一个线程独霸GIL的。计时器线程只是一个存在于MRI内部的原生线程；它没有相应的Ruby线程。计时器线程在MRI启动时以[rb_thread_create_timer_thread](https://github.com/ruby/ruby/blob/trunk/thread_pthread.c#L1399)函数启动。

当MRI启动并只有主线程运行时，计时器线程沉睡。但请记住，一旦有一个线程在等待GIL,它即会唤醒计时器线程。

![](http://cdn.shopify.com/s/files/1/0110/8792/files/sleeping-timer_large.png?696)

这张图更近乎于MRI中GIL的实现。回想之前的片段，我刚刚衍生出最右边的线程。因为它是唯一在等待GIL的，就是它唤醒计时器线程的。

计时器线程是用来避免一个线程独霸GIL的。每100毫秒，计时器线程在当前持有GIL的线程上设置一个中断标志，使用 **RUBY_VM_SET_TIMER_INTERRUPT** 宏。这里的细节需要注意，因为这会给**array << nil** 是否是原子性操作这个问题提供线索。

如果你熟悉[时间片](https://en.wikipedia.org/wiki/Preemption_(computing)#Time_slice)的概念，与此很相似。

每100毫秒计时器线程会在当前持有GIL的线程上设置中断标记。设置中断标记并不实际中断线程的执行。如果是这样的话，我们可以肯定**array << nil**不是一个原子性操作。

### 控制中断标志

深入名为**vm_eval.c**的文件，包含了控制Ruby方法调用的代码。它有负责创建方法调用的上下文，并调用正确的方法。在方法结束时调用[vm_call0_body](https://github.com/ruby/ruby/blob/trunk/vm_eval.c#L238)，正当它返回当前方法的返回值之前，这些中断会被检查。

如果这个线程已经被设置了中断标志，则在返回其值前当场停止执行。在执行更多Ruby代码之前，当前线程会释放GIL并调用**sched_yield**。**sched_yield**是一个系统方法提示线程调度器安排另一个线程。一旦完成这个工作，该中断线程尝试重新获取GIL，现在不得不等待另一个线程释放GIL了。

嘿，这就是我们问题的答案。**array << nil**是原子性的。多亏了GIL，所有用C实现的Ruby方法都是原子性的。

所以这个例子:

```ruby
array = []

5.times.map do
  Thread.new do
    1000.times do
      array << nil
    end
  end
end.each(&:join)

puts array.size
```

运行在MRI上每次都保证产生预期的结果。

**但请记住，这个保证并不针对Ruby写成的那些代码。**如果你把这段代码放到没有GIL的其他实现里，它将会产生叵测的结果。很有必要了解一个GIL保证，但依赖它来写代码就不是个好主意了。在此过程中，你基本就把自己和MRI捆绑在一块儿了。

相似的，GIL不是公开的API。没有文档和规程说明。虽说Ruby代码是隐式依赖GIL的，但之前的MRI团队曾谈及想摆脱GIL或改变其语义。出于这些原因，你当然不希望，写出来的代码只能依赖于现下GIL的行为吧。

### 非原生方法

目前为止，我说到**array << nil**是原子性的。这很简单，因为**Array#<<**方法只带一个参数。这个表达式里只有一个方法调用，并且它是用C实现的。如果它在过程中被中断了，只会继续直到完成，之后释放GIL。

那类似这样的呢？

```ruby
array << User.find(1)
```

在**Array#<<**方法执行前，它先要对右侧的表达式进行求值，然后才能把表达式的值作为参数。所以**User.find(1)**必须先被调用。如你所知，**User.find(1)**会调用一大堆其他Ruby代码。

所以，在上面的例子中 **Array#<<** 依然是原子性的吗？是的，但是一旦右手边被求值。换句话说，没有原子性保证**User.find(1)**方法将被调用。之后返回值会传给 有原子性保证的**Array#<<**。

更新: [ @headius ](https://twitter.com/headius)发了一个[极好的评论](http://www.jstorimer.com/blogs/workingwithcode/8100871-nobody-understands-the-gil-part-2-implementation#comment-930773796)，扩展了GIL提供的保证。如果你读到这个，考虑必读一下。

### 这一切意味着什么？

GIL使得方法调用原子性。这个对你意味着什么呢？

在Part I中，我举例展示了在C函数中发生上下文切换时会发生什么。使用GIL，这种情况不会再发生了。相反，如果上下文切换发生了，其他线程会保持空闲以待GIL，给当前线程机会继续不中断。此行为只适用于MRI用C实现的Ruby方法。

这种行为消除了竞争条件的源头，不然MRI的内部竞争会防不胜防。从这个角度，GIL是一个严格的MRI内部实现细节。它保持MRI的安全。

但是还有一个挥之不去的问题尚无答案。GIL能提供给你的Ruby代码线程安全保证吗？


这是一个MRI使用中的重要问题，要是你熟悉其他环境的多线程编程,你可能已经知道了，答案是一个大写的**不行**。但是这篇文章已经足够长了，我将会在[Part III](http://www.rubyinside.com/does-the-gil-make-your-ruby-code-thread-safe-6051.html)更彻底地解决这个问题。
